definition

module Stratego-Sugar-Overlays
imports Stratego-Core-Identifiers Stratego-Sugar-Terms

exports
  sorts WATER WATERTOKEN WATERTOKENSTART WATERTOKENSEPARATOR WATERTOKENSTAR

  lexical syntax
    ~[A-Za-z0-9\_]                 -> WATERTOKENSTART     {recover, avoid}
    WATERTOKENSTART [A-Za-z0-9\_]* -> WATERTOKEN          
    ~[A-Za-z0-9\_\ \t\12\r\n\*]    -> WATERTOKENSEPARATOR {recover, avoid}
    "*"                            -> WATERTOKENSTAR      {recover, avoid}
    WATERTOKEN                     -> WATER               
    WATERTOKENSEPARATOR            -> WATER               
    WATERTOKENSTAR                 -> WATER               
                                   -> WATEREOF            

  lexical restrictions
    WATERTOKEN -/- [A-Za-z0-9\_]
    WATERTOKENSTAR -/- [\/]

  context-free syntax
    WATER -> LAYOUT {cons("WATER")}

  (

  sorts WATEREOF

  lexical restrictions
    WATEREOF -/- ~[]

  lexical syntax
    %% Lexical insertion recovery rules                     
                                         -> "|}"            {recover, cons("INSERTION")}
                                         -> ">"             {recover, cons("INSERTION")}
                                         -> "\\"            {recover, cons("INSERTION")}
                                         -> "]"             {recover, cons("INSERTION")}
                                         -> "sorts"         {recover, cons("INSERTION")}
                                         -> "constructors"  {recover, cons("INSERTION")}
                                         -> ":"             {recover, cons("INSERTION")}
                                         -> "end"           {recover, cons("INSERTION")}
                                         -> "}"             {recover, cons("INSERTION")}
                                         -> ")"             {recover, cons("INSERTION")}
                                         -> "specification" {recover, cons("INSERTION")}
                                         -> "strategies"    {recover, cons("INSERTION")}
                                         -> "signature"     {recover, cons("INSERTION")}
                                         -> "overlays"      {recover, cons("INSERTION")}
    "\""                                 -> INSERTOPENQUOTE {recover}
    INSERTOPENQUOTE StrChar* "\n"        -> String          {cons("INSERTEND")}
    INSERTOPENQUOTE StrChar* WATEREOF    -> String          {cons("INSERTEND")}
    "'"                                  -> INSERTOPENQUOTE {recover}
    INSERTOPENQUOTE CharChar "\n"        -> Char            {cons("INSERTEND")}
    INSERTOPENQUOTE CharChar WATEREOF    -> Char            {cons("INSERTEND")}
                                         -> "pp-table"      {recover, cons("INSERTION")}
                                         -> "pretty-print"  {recover, cons("INSERTION")}
                                         -> "refactoring"   {recover, cons("INSERTION")}
                                         -> "token"         {recover, cons("INSERTION")}
                                         -> "italic"        {recover, cons("INSERTION")}
                                         -> "bold"          {recover, cons("INSERTION")}
                                         -> "provider"      {recover, cons("INSERTION")}
                                         -> "on"            {recover, cons("INSERTION")}
                                         -> ","             {recover, cons("INSERTION")}
                                         -> "name"          {recover, cons("INSERTION")}
                                         -> "extensions"    {recover, cons("INSERTION")}
                                         -> "description"   {recover, cons("INSERTION")}
                                         -> "table"         {recover, cons("INSERTION")}
                                         -> "start"         {recover, cons("INSERTION")}
                                         -> "url"           {recover, cons("INSERTION")}
                                         -> "extends"       {recover, cons("INSERTION")}
                                         -> "aliases"       {recover, cons("INSERTION")}
                                         -> "*"             {recover, cons("INSERTION")}
                                         -> "disambiguator" {recover, cons("INSERTION")}
    "\""                                 -> INSERTOPENQUOTE {recover}
    INSERTOPENQUOTE StringChar* "\n"     -> STRING          {cons("INSERTEND")}
    INSERTOPENQUOTE StringChar* WATEREOF -> STRING          {cons("INSERTEND")}
    "/*"                                 -> INSERTSTART     {recover}
    INSERTSTART CommChar* WATEREOF       -> LongCom         {cons("INSERTEND")}
                                         -> "module"        {recover, cons("INSERTION")}
                                         -> "imports"       {recover, cons("INSERTION")}
                                         -> "descriptor"    {recover, cons("INSERTION")}
                                         -> "]|"            {recover, cons("INSERTION")}
                                         -> "|["            {recover, cons("INSERTION")}
                                         -> "~*"            {recover, cons("INSERTION")}
                                         -> "~anno:"        {recover, cons("INSERTION")}

  syntax
    %% Kernel syntax insertion recovery rules                          
    "$"                                           -> INSERTOPENQUOTE   {recover}
    INSERTOPENQUOTE <QuotedBracket1-LEX> "\n"     -> StringQuotedPart1 {cons("INSERTEND")}
    INSERTOPENQUOTE <QuotedBracket1-LEX> WATEREOF -> StringQuotedPart1 {cons("INSERTEND")}
    "$"                                           -> INSERTOPENQUOTE   {recover}
    INSERTOPENQUOTE <QuotedBracket2-LEX> "\n"     -> StringQuotedPart2 {cons("INSERTEND")}
    INSERTOPENQUOTE <QuotedBracket2-LEX> WATEREOF -> StringQuotedPart2 {cons("INSERTEND")}
    "$"                                           -> INSERTOPENQUOTE   {recover}
    INSERTOPENQUOTE <QuotedBracket3-LEX> "\n"     -> StringQuotedPart3 {cons("INSERTEND")}
    INSERTOPENQUOTE <QuotedBracket3-LEX> WATEREOF -> StringQuotedPart3 {cons("INSERTEND")}
    "$"                                           -> INSERTOPENQUOTE   {recover}
    INSERTOPENQUOTE <QuotedBracket4-LEX> "\n"     -> StringQuotedPart4 {cons("INSERTEND")}
    INSERTOPENQUOTE <QuotedBracket4-LEX> WATEREOF -> StringQuotedPart4 {cons("INSERTEND")}

  )

  (

  sorts Overlay

  context-free syntax
    Id "=" Term                   -> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term -> Overlay {cons("Overlay")}

  )

module Stratego-Sugar-DynamicRules
imports Stratego-Core-Identifiers Stratego-Sugar-Strategies Stratego-Sugar-Rules

exports
  sorts ScopeLabels

  context-free syntax
    "{|" ScopeLabels ":" Strategy "|}" -> Strategy    {cons("DynRuleScope")}
    {DynRuleScopeId ","}*              -> ScopeLabels 
    "~" Term                           -> ScopeLabels {cons("ScopeLabels")}

  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec

  context-free syntax
    "rules" "(" DynRuleDef* ")"            -> Strategy       {cons("GenDynRules")}
    Id "+" Term                            -> DynRuleDef     {cons("AddScopeLabel")}
    DynRuleId ":-" Term                    -> DynRuleDef     {cons("UndefineDynRule")}
    DynRuleId ":" Rule                     -> DynRuleDef     {cons("SetDynRule")}
    DynRuleId ":+" Rule                    -> DynRuleDef     {cons("AddDynRule")}
    DynRuleId ":" Term                     -> DynRuleDef     {cons("SetDynRuleMatch")}
    DynRuleId ":=" Term                    -> DynRuleDef     {cons("DynRuleAssign")}
    DynRuleId ":+=" Term                   -> DynRuleDef     {cons("DynRuleAssignAdd")}
    DynRuleId ":" Rule "depends" "on" Term -> DynRuleDef     {cons("SetDynRuleDepends")}
    RuleDec "." Term                       -> DynRuleId      {cons("LabeledDynRuleId")}
    RuleDec "+" Term                       -> DynRuleId      {cons("AddLabelDynRuleId")}
    RuleDec                                -> DynRuleId      {cons("DynRuleId")}
    Id "." Term                            -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
    Id                                     -> DynRuleScopeId {cons("DynRuleScopeId")}

  context-free syntax
    Id                                           -> RuleDec {cons("RDecNoArgs")}
    Id "(" {Typedid ","}* ")"                    -> RuleDec {cons("RDec")}
    Id "(" {Typedid ","}* "|" {Typedid ","}* ")" -> RuleDec {cons("RDecT")}

  sorts RuleNames

  context-free syntax
    {Id ","}*                    -> RuleNames 
    "~" Term                     -> RuleNames {cons("RuleNames")}
    "/" RuleNames "\\*" Strategy -> Strategy  {cons("DynRuleIntersectFix")}

  syntax
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>                                               -> <Strategy-CF> {cons("DynRuleUnionFix")}
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>                                              -> <Strategy-CF> {cons("DynRuleUnionFix")}
    "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>  -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
    "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF> -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

  context-free syntax
    Strategy "/" RuleNames "\\" Strategy               -> Strategy {cons("DynRuleIntersect"), right}
    Strategy "\\" RuleNames "/" Strategy               -> Strategy {cons("DynRuleUnion"), right}
    Strategy "/" RuleNames "\\" RuleNames "/" Strategy -> Strategy {cons("DynRuleIntersectUnion"), right}

  priorities
    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")} >
    { "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF> ->
      <Strategy-CF> {cons("DynRuleUnionFix")}
      "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF> ->
      <Strategy-CF> {cons("DynRuleUnionFix")}
      
      "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
      
      "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")} } >
    <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF>
    {cons("AM")}

  context-free priorities
    StrategyAngle Term -> Strategy {cons("BA")} >
    "/" RuleNames "\\*" Strategy -> Strategy {cons("DynRuleIntersectFix")} >
    Strategy "=>" Term -> Strategy {cons("AM")} >
    Strategy "/" RuleNames "\\" Strategy -> Strategy
    {cons("DynRuleIntersect"), right} >
    Strategy "\\" RuleNames "/" Strategy -> Strategy
    {cons("DynRuleUnion"), right} >
    Strategy "/" RuleNames "\\" RuleNames "/" Strategy -> Strategy
    {cons("DynRuleIntersectUnion"), right} >
    Strategy ";" Strategy -> Strategy {cons("Seq"), right}

module Stratego-Sugar-Rules
imports Stratego-Sugar-Strategies

exports
  sorts RuleDef

  context-free syntax
    Id ":" Rule                                           -> RuleDef {cons("RDefNoArgs")}
    Anno+ RuleDef                                         -> Def     {cons("AnnoDef")}
    Id "(" {Typedid ","}* ")" ":" Rule                    -> RuleDef {cons("RDef")}
    Id "(" {Typedid ","}* "|" {Typedid ","}* ")" ":" Rule -> RuleDef {cons("RDefT")}

  sorts Rule RuleCond

  context-free syntax
    Term "->" Term                  -> Rule     {cons("RuleNoCond")}
    Term "->" Term "where" Strategy -> Rule     {cons("Rule")}
    Term "->" Term RuleCond+        -> Rule     {cons("Rule"), avoid}
    "where" Strategy                -> RuleCond {cons("WhereClause")}
    "with" Strategy                 -> RuleCond {cons("WithClause")}

module Stratego-Sugar-Strategies
imports Stratego-Core-Strategies Stratego-Sugar-Terms Stratego-Sugar-Constants
        Stratego-Sugar-Signatures

exports
  context-free syntax
    Id "=" Strategy                        -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

  context-free syntax
    ID -> Typedid {cons("DefaultVarDec")}

  sorts Rule

  sorts StrategyParen StrategyCurly StrategyAngle

  context-free syntax
    SVar "(" {Strategy ","}* ")"          -> Strategy      {cons("Call")}
    "{" Strategy "}"                      -> Strategy      {cons("ScopeDefault")}
    StrategyAngle Term                    -> Strategy      {cons("BA")}
    "<" Strategy ">"                      -> StrategyAngle {bracket}
    Strategy "<+" Strategy                -> Strategy      {cons("LChoice"), right}
    "rec" Id "(" Strategy ")"             -> Strategy      {cons("Rec")}
    "not" "(" Strategy ")"                -> Strategy      {cons("Not")}
    "where" "(" Strategy ")"              -> Strategy      {cons("Where")}
    "with" "(" Strategy ")"               -> Strategy      {cons("With"), prefer}
    "test" "(" Strategy ")"               -> Strategy      {cons("Test")}
    "prim" "(" String ")"                 -> Strategy      {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy      {cons("Prim")}
    String                                -> Strategy      {cons("StrCong")}
    Int                                   -> Strategy      {cons("IntCong")}
    Real                                  -> Strategy      {cons("RealCong")}
    Char                                  -> Strategy      {cons("CharCong")}
    String "(" {Strategy ","}* ")"        -> Strategy      {cons("CongQ")}
    Strategy StrategyCurly                -> Strategy      {cons("AnnoCong")}
    "{" Strategy "}"                      -> StrategyCurly {cons("StrategyCurly")}
    "(" ")"                               -> Strategy      {cons("EmptyTupleCong")}
    "(" Strategy ")"                      -> Strategy      {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy      {cons("TupleCong")}
    "[" {Strategy ","}* "]"               -> Strategy      {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy      {cons("ListCong")}
    Strategy "#" StrategyParen            -> Strategy      {cons("ExplodeCong")}

  sorts SwitchCase

  context-free syntax
    SVar                                                         -> Strategy   {cons("CallNoArgs")}
    "\\" Rule "\\"                                               -> Strategy   {cons("LRule")}
    "(" Rule ")"                                                 -> Strategy   {cons("SRule")}
    Strategy "+" Strategy                                        -> Strategy   {cons("Choice"), right}
    Strategy "+>" Strategy                                       -> Strategy   {cons("RChoice"), right}
    "proceed" "(" {Strategy ","}+ ")"                            -> Strategy   {cons("Proceed"), prefer}
    "if" Strategy "then" Strategy "else" Strategy "end"          -> Strategy   {cons("CondChoice")}
    "if" Strategy "then" Strategy "end"                          -> Strategy   {cons("IfThen")}
    "switch" Strategy SwitchCase* "end"                          -> Strategy   {cons("SwitchChoiceNoOtherwise")}
    "switch" Strategy SwitchCase* "otherwise" ":" Strategy "end" -> Strategy   {cons("SwitchChoice")}
    "case" Strategy ":" Strategy                                 -> SwitchCase {cons("SwitchCase")}
    Strategy "=>" Term                                           -> Strategy   {cons("AM")}
    Term ":=" Term                                               -> Strategy   {cons("Assign")}

  context-free priorities
    { Strategy StrategyCurly -> Strategy 
      Strategy "#" StrategyParen -> Strategy  } >
    { "!" Term -> Strategy 
      "?" Term -> Strategy  } >
    StrategyAngle Term -> Strategy  >
    Strategy "=>" Term -> Strategy  >
    Strategy ";" Strategy -> Strategy  >
    {right:
      Strategy "+" Strategy -> Strategy 
      Strategy "<+" Strategy -> Strategy 
      Strategy "+>" Strategy -> Strategy 
      Strategy "<" StrategyMid "+" Strategy -> Strategy 
    }

  context-free priorities
    Strategy -> StrategyMid  >
    Strategy "+" Strategy -> Strategy 

  context-free priorities
    { Strategy StrategyCurly -> Strategy 
      Strategy "#" StrategyParen -> Strategy  } . >
    Term ":=" Term -> Strategy 

module Stratego-Sugar-Terms
imports Stratego-Core-Terms Stratego-Sugar-Strategies

exports
  sorts LID

  context-free syntax
    LId -> LID {cons("ListVar")}
    LID -> Var {cons("Var")}
    LID -> ID  

  context-free syntax
    "_" PreTerm                  -> PreTerm {cons("BuildDefaultPT")}
    "_" Term                     -> Term    {cons("BuildDefault"), prefer}
    Char                         -> PreTerm {cons("Char")}
    PreTerm "{" {Term ","}* "}"  -> Term    {cons("AnnoList")}
    PreTerm                      -> Term    {cons("NoAnnoList")}
    "<" Strategy ">" Term        -> PreTerm {cons("App")}
    "<" Strategy ">" Term        -> Term    {cons("App"), prefer}
    StrategyAngle                -> PreTerm {cons("RootApp")}
    StrategyAngle                -> Term    {cons("RootApp"), prefer}
    "(" {Term ","}* ")"          -> PreTerm {cons("Tuple")}
    "[" {Term ","}* "]"          -> PreTerm {cons("List")}
    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}

  context-free priorities
    Term "#" "(" Term ")" -> PreTerm {cons("Explode")} >
    PreTerm "{" {Term ","}* "}" -> Term {cons("AnnoList")} >
    Var "@" Term -> Term {cons("As")}

module Stratego-Sugar-Signatures
imports Stratego-Core-Signatures Stratego-Sugar-Constants

exports
  sorts Sort

  context-free syntax
    "[" {Sort ","}* "]"          -> Sort {cons("SortList")}
    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
    "(" {Sort ","}* ")"          -> Sort {cons("SortTuple")}

  sorts Kind

  context-free syntax
    "*"  -> Kind {cons("Star")}
    "**" -> Kind {cons("StarStar")}

module Stratego-Core-Signatures
imports Stratego-Core-Identifiers Stratego-Core-Constants

exports
  sorts Sdecl

  context-free syntax
    "sorts" Sort*          -> Sdecl {cons("Sorts")}
    "constructors" Opdecl* -> Sdecl {cons("Constructors")}

  sorts Sort

  context-free syntax
    LCID                   -> Sort {cons("SortVar")}
    UCID                   -> Sort {cons("SortNoArgs")}
    Id "(" {Sort ","}* ")" -> Sort {cons("Sort")}

  sorts Opdecl

  context-free syntax
    Id ":" Type     -> Opdecl {cons("OpDecl")}
    String ":" Type -> Opdecl {cons("OpDeclQ")}
    ":" Type        -> Opdecl {cons("OpDeclInj")}

  context-free syntax
    "external" Id ":" Type     -> Opdecl {cons("ExtOpDecl")}
    "external" String ":" Type -> Opdecl {cons("ExtOpDeclQ")}
    "external" ":" Type        -> Opdecl {cons("ExtOpDeclInj")}

  sorts Type ArgType ConstType FunType RetType

  context-free syntax
    Sort                        -> ConstType {cons("ConstType")}
    {ArgType "*"}+ "->" RetType -> FunType   {cons("FunType")}
    "(" Type ")"                -> ArgType   {bracket}
    ConstType                   -> ArgType   
    Type                        -> RetType   
    FunType                     -> RetType   {reject}
    FunType                     -> Type      
    ConstType                   -> Type      

  context-free restrictions
    Sort -/- [\(]

module Stratego-Core-Terms
imports Stratego-Core-Identifiers Stratego-Core-Constants

exports
  sorts ID Var Wld

  context-free syntax
    Id -> Var {cons("Var")}
    Id -> ID  

  sorts Term PreTerm

  context-free syntax
    Var                        -> PreTerm 
    Var                        -> Term    {prefer}
    "_"                        -> Wld     {cons("Wld")}
    Wld                        -> PreTerm 
    Wld                        -> Term    {prefer}
    Int                        -> PreTerm {cons("Int")}
    Real                       -> PreTerm {cons("Real")}
    String                     -> PreTerm {cons("Str")}
    Id "(" {Term ","}* ")"     -> PreTerm {cons("Op")}
    String "(" {Term ","}* ")" -> PreTerm {cons("OpQ")}
    Term "#" "(" Term ")"      -> PreTerm {cons("Explode")}
    PreTerm "{^" PreTerm "}"   -> Term    {cons("Anno")}
    Var "@" Term               -> Term    {cons("As"), prefer}
    Var "@" PreTerm            -> PreTerm {cons("As")}

  context-free priorities
    Term "#" "(" Term ")" -> PreTerm {cons("Explode")} >
    Var "@" Term -> Term {cons("As")}

module Stratego-Core-Strategies
imports Stratego-Core-Terms Stratego-Core-Constants Stratego-Core-Signatures

exports
  sorts Def

  context-free syntax
    StrategyDef                                             -> Def      
    Id                                                      -> SVar     {cons("SVar")}
    "let" Def* "in" Strategy "end"                          -> Strategy {cons("Let")}
    SVar "(" {Strategy ","}* "|" {Term ","}* ")"            -> Strategy {cons("CallT")}
    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}

  sorts StrategyDef

  context-free syntax
    Id "(" {Typedid ","}* "|" {Typedid ","}* ")" "=" Strategy            -> StrategyDef {cons("SDefT")}
    Anno+ StrategyDef                                                    -> Def         {cons("AnnoDef")}
    "external" Id "(" {Typedid ","}* "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}
    "external" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"              -> StrategyDef {cons("ExtSDef")}
    "external" EmptyId "(" {Typedid ","}* "|" {Typedid ","}* ")"         -> StrategyDef {cons("ExtSDef")}

  sorts EmptyId

  lexical syntax
     -> EmptyId 

  sorts Anno

  context-free syntax
    "extend"   -> Anno {cons("Extend")}
    "override" -> Anno {cons("Override")}
    "internal" -> Anno {cons("Internal")}

  lexical syntax
    "extend"      -> Keyword 
    "override"    -> Keyword 
    "internal"    -> Keyword 
    "sealed"      -> Keyword 
    "extensible"  -> Keyword 
    "overridable" -> Keyword 

  lexical restrictions
    "extend" "override" "internal" "sealed" "extensible" "overridable"
    -/- [a-zA-Z0-9\'\-\_]

  sorts Typedid

  context-free syntax
    ID ":" Type -> Typedid {cons("VarDec")}

  sorts Strategy SVar StrategyParen StrategyMid

  context-free syntax
    "(" Strategy ")"                                          -> StrategyParen {cons("ParenStrat")}
    "fail"                                                    -> Strategy      {cons("Fail")}
    "id"                                                      -> Strategy      {cons("Id")}
    "proceed" "(" {Strategy ","}* "|" {Term ","}* ")"         -> Strategy      {cons("ProceedT"), prefer}
    "proceed"                                                 -> Strategy      {cons("ProceedNoArgs"), prefer}
    "?" Term                                                  -> Strategy      {cons("Match")}
    "!" Term                                                  -> Strategy      {cons("Build")}
    "{" {ID ","}* ":" Strategy "}"                            -> Strategy      {cons("Scope")}
    Strategy ";" Strategy                                     -> Strategy      {cons("Seq"), right}
    Strategy "<" StrategyMid "+" Strategy                     -> Strategy      {cons("GuardedLChoice"), right}
    Strategy                                                  -> StrategyMid   
    "prim" "(" String "," {Strategy ","}* "|" {Term ","}* ")" -> Strategy      {cons("PrimT")}
    "some" "(" Strategy ")"                                   -> Strategy      {cons("Some")}
    "one" "(" Strategy ")"                                    -> Strategy      {cons("One")}
    "all" "(" Strategy ")"                                    -> Strategy      {cons("All")}

  context-free priorities
    { "!" Term -> Strategy {cons("Build")}
      "?" Term -> Strategy {cons("Match")} } >
    Strategy ";" Strategy -> Strategy {cons("Seq"), right} >
    {right:
      Strategy "<" StrategyMid "+" Strategy -> Strategy
      {cons("GuardedLChoice"), right}
    }

  context-free syntax
    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}

module Stratego-Core-Modules
imports Stratego-Core-Identifiers Stratego-Core-Strategies
        Stratego-Core-Signatures

exports
  sorts Module

  context-free syntax
    "module" ModName Decl* -> Module {cons("Module")}
    "specification" Decl*  -> Module {cons("Specification")}

  sorts Decl

  context-free syntax
    "imports" ImportModName* -> Decl {cons("Imports")}
    "strategies" Def*        -> Decl {cons("Strategies")}
    "signature" Sdecl*       -> Decl {cons("Signature")}

  sorts ImportModName

  context-free syntax
    ModName -> ImportModName {cons("Import")}

  syntax
    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}

module Stratego-Sugar-Modules
imports Stratego-Core-Modules Stratego-Sugar-Strategies
        Stratego-Sugar-Signatures Stratego-Sugar-Overlays Stratego-Sugar-Rules

exports
  sorts Decl Def

  context-free syntax
    "rules" Def*        -> Decl {cons("Rules")}
    "overlays" Overlay* -> Decl {cons("Overlays")}
    RuleDef             -> Def  

module Stratego-Sugar-StringQuotations
exports
  sorts StringQuotation StringQuotedPart1 StringQuotedChars1 DollarOpen1
        DollarClose1 QuotedBracket1 Dollar1 StringQuotedPart2 StringQuotedChars2
        DollarOpen2 DollarClose2 QuotedBracket2 Dollar2 StringQuotedPart3
        StringQuotedChars3 DollarOpen3 DollarClose3 QuotedBracket3 Dollar3
        StringQuotedPart4 StringQuotedChars4 DollarOpen4 DollarClose4
        QuotedBracket4 Dollar4 Padding

  context-free syntax
    StringQuotation -> PreTerm 

  syntax
    StringQuotation                                     -> <PreTerm-CF>             
    "$" "[" Padding StringQuotedPart1* "]"              -> StringQuotation          {cons("StringQuotation1")}
    Padding "[" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "]" -> StringQuotedPart1        {cons("StringEscape1")}
    <StringQuotedChars1-LEX>                            -> StringQuotedPart1        {cons("QStr")}
    <Dollar1-LEX>                                       -> StringQuotedPart1        {cons("QDollar")}
    "$" <QuotedBracket1-LEX> "$"                        -> StringQuotedPart1        {cons("QBr")}
    ~[\[\]\$]+                                          -> <StringQuotedChars1-LEX> 
    [\[\]]                                              -> <QuotedBracket1-LEX>     
    "$"                                                 -> <Dollar1-LEX>            
    "$" "{" Padding StringQuotedPart2* "}"              -> StringQuotation          {cons("StringQuotation2")}
    Padding "{" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "}" -> StringQuotedPart2        {cons("StringEscape2")}
    <StringQuotedChars2-LEX>                            -> StringQuotedPart2        {cons("QStr")}
    <Dollar2-LEX>                                       -> StringQuotedPart2        {cons("QDollar")}
    "$" <QuotedBracket2-LEX> "$"                        -> StringQuotedPart2        {cons("QBr")}
    ~[\{\}\$]+                                          -> <StringQuotedChars2-LEX> 
    [\{\}]                                              -> <QuotedBracket2-LEX>     
    "$"                                                 -> <Dollar2-LEX>            
    "$" "(" Padding StringQuotedPart3* ")"              -> StringQuotation          {cons("StringQuotation3")}
    Padding "(" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ")" -> StringQuotedPart3        {cons("StringEscape3")}
    <StringQuotedChars3-LEX>                            -> StringQuotedPart3        {cons("QStr")}
    <Dollar3-LEX>                                       -> StringQuotedPart3        {cons("QDollar")}
    "$" <QuotedBracket3-LEX> "$"                        -> StringQuotedPart3        {cons("QBr")}
    ~[\(\)\$]+                                          -> <StringQuotedChars3-LEX> 
    [\(\)]                                              -> <QuotedBracket3-LEX>     
    "$"                                                 -> <Dollar3-LEX>            
    "$" "<" Padding StringQuotedPart4* ">"              -> StringQuotation          {cons("StringQuotation4")}
    Padding "<" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ">" -> StringQuotedPart4        {cons("StringEscape4")}
    <StringQuotedChars4-LEX>                            -> StringQuotedPart4        {cons("QStr")}
    <Dollar4-LEX>                                       -> StringQuotedPart4        {cons("QDollar")}
    "$" <QuotedBracket4-LEX> "$"                        -> StringQuotedPart4        {cons("QBr")}
    ~[\<\>\$]+                                          -> <StringQuotedChars4-LEX> 
    [\<\>]                                              -> <QuotedBracket4-LEX>     
    "$"                                                 -> <Dollar4-LEX>            
    <Padding-LEX>                                       -> Padding                  
                                                        -> <Padding-LEX>            {indentpadding}

  lexical restrictions
    StringQuotedChars1 -/- ~[\[\]\$]
    StringQuotedChars2 -/- ~[\{\}\$]
    StringQuotedChars3 -/- ~[\(\)\$]
    StringQuotedChars4 -/- ~[\<\>\$]
    Dollar1 -/- [\[\]] . [\$]
    Dollar2 -/- [\{\}] . [\$]
    Dollar3 -/- [\(\)] . [\$]
    Dollar4 -/- [\<\>] . [\$]

module Stratego-Core-Constants
exports
  sorts Int Real String StrChar

  lexical syntax
    [\-]? [0-9]+             -> Int     
    [\-]? [0-9]+ [\.] [0-9]+ -> Real    
    "\"" StrChar* "\""       -> String  
    ~[\"\\]                  -> StrChar 
    [\\] [\"tnr\\]           -> StrChar 

module Stratego-Sugar-Constants
imports Stratego-Core-Identifiers Stratego-Core-Constants
        Stratego-Sugar-StringQuotations

exports
  sorts Char CharChar

  lexical syntax
    "'" CharChar "'" -> Char     
    ~[\']            -> CharChar 
    [\\] [\'ntr\ ]   -> CharChar 
    Char             -> Id       {reject}

module Stratego-Core-Identifiers
exports
  sorts ModName ModNamePart

  lexical syntax
    {ModNamePart "/"}+                -> ModName     
    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart 

  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]

  lexical syntax
    "imports"    -> ModName {reject}
    "overlays"   -> ModName {reject}
    "rules"      -> ModName {reject}
    "signature"  -> ModName {reject}
    "strategies" -> ModName {reject}

  sorts Id LId LCID UCID Wld

  lexical syntax
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id   
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId  
    [\'] [a-z]+                       -> Id   
    [a-z] [a-zA-Z0-9\'\-\_]*          -> LCID 
    [A-Z] [a-zA-Z0-9\'\-\_]*          -> UCID 

  lexical restrictions
    Id -/- [a-zA-Z0-9\'\_\*]
    Id -/- [\-] . ~[\>]
    LId -/- [a-zA-Z0-9\'\-\_]
    LCID -/- [a-zA-Z0-9\'\-\_]
    UCID -/- [a-zA-Z0-9\'\-\_]

  lexical syntax
    "_"     -> Id   {reject}
    "'"     -> Id   {reject}
    Keyword -> Id   {reject}
    Keyword -> LId  {reject}
    Keyword -> LCID {reject}
    Keyword -> UCID {reject}

  lexical restrictions
    "all" "case" "constructors" "else" "end" "external" "fail" "id" "if" "in"
    "imports" "let" "module" "not" "one" "overlays" "otherwise" "prim" "rec"
    "rules" "script" "signature" "some" "sorts" "strategies" "stratego" "switch"
    "test" "then" "where" "import-term" -/- [a-zA-Z0-9\'\-\_]

  context-free restrictions
    Wld -/- [a-zA-Z0-9\'\-\_]

  sorts Keyword

  lexical syntax
    "all"          -> Keyword 
    "constructors" -> Keyword 
    "fail"         -> Keyword 
    "id"           -> Keyword 
    "in"           -> Keyword 
    "let"          -> Keyword 
    "module"       -> Keyword 
    "not"          -> Keyword 
    "one"          -> Keyword 
    "overlays"     -> Keyword 
    "prim"         -> Keyword 
    "rules"        -> Keyword 
    "script"       -> Keyword 
    "signature"    -> Keyword 
    "some"         -> Keyword 
    "sorts"        -> Keyword 
    "strategies"   -> Keyword 
    "stratego"     -> Keyword 
    "test"         -> Keyword 
    "where"        -> Keyword 
    "import-term"  -> Keyword 

module Stratego-Core-Layout
exports
  sorts Ws ShortCom LongCom CommChar Asterisk Eof

  lexical syntax
    [\t\ \n\r]             -> Ws       
    "//" ~[\n]* [\n] | Eof -> ShortCom 
    "/*" CommChar* "*/"    -> LongCom  
                           -> Eof      
    ~[\*]                  -> CommChar 
    "*"                    -> Asterisk 
    Asterisk               -> CommChar 

  lexical restrictions
    Asterisk -/- [\/]
    Eof -/- ~[]

  lexical syntax
    ShortCom -> LAYOUT 
    LongCom  -> LAYOUT 
    Ws       -> LAYOUT 

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/] . [\*]
    LAYOUT? -/- [\/] . [\/]

module Stratego-Sugar-Layout
imports Stratego-Core-Layout

module Stratego-Sugar
imports Stratego-Sugar-Layout Stratego-Core-Identifiers Stratego-Sugar-Constants
        Stratego-Sugar-Modules Stratego-Sugar-Signatures Stratego-Sugar-Terms
        Stratego-Sugar-Strategies Stratego-Sugar-Rules
        Stratego-Sugar-DynamicRules Stratego-Sugar-Overlays

hiddens
  context-free start-symbols
    Module

module Stratego
imports Stratego-Sugar

hiddens
  context-free start-symbols
    Module

module StrategoMix[Ctx0]
imports Stratego
          [ RuleNames          => RuleNames[[Ctx0]]
            RuleDec            => RuleDec[[Ctx0]]
            DynRuleScopeId     => DynRuleScopeId[[Ctx0]]
            DynRuleId          => DynRuleId[[Ctx0]]
            DynRuleDef         => DynRuleDef[[Ctx0]]
            ScopeLabels        => ScopeLabels[[Ctx0]]
            RuleCond           => RuleCond[[Ctx0]]
            Rule               => Rule[[Ctx0]]
            RuleDef            => RuleDef[[Ctx0]]
            Overlay            => Overlay[[Ctx0]]
            SwitchCase         => SwitchCase[[Ctx0]]
            StrategyCurly      => StrategyCurly[[Ctx0]]
            StrategyAngle      => StrategyAngle[[Ctx0]]
            Kind               => Kind[[Ctx0]]
            LID                => LID[[Ctx0]]
            ImportModName      => ImportModName[[Ctx0]]
            Decl               => Decl[[Ctx0]]
            Module             => Module[[Ctx0]]
            StrategyParen      => StrategyParen[[Ctx0]]
            Typedid            => Typedid[[Ctx0]]
            Anno               => Anno[[Ctx0]]
            EmptyId            => EmptyId[[Ctx0]]
            StrategyDef        => StrategyDef[[Ctx0]]
            SVar               => SVar[[Ctx0]]
            Def                => Def[[Ctx0]]
            Type               => Type[[Ctx0]]
            RetType            => RetType[[Ctx0]]
            ArgType            => ArgType[[Ctx0]]
            FunType            => FunType[[Ctx0]]
            ConstType          => ConstType[[Ctx0]]
            Opdecl             => Opdecl[[Ctx0]]
            Sort               => Sort[[Ctx0]]
            Sdecl              => Sdecl[[Ctx0]]
            Wld                => Wld[[Ctx0]]
            ID                 => ID[[Ctx0]]
            Var                => Var[[Ctx0]]
            CharChar           => CharChar[[Ctx0]]
            Char               => Char[[Ctx0]]
            Padding            => Padding[[Ctx0]]
            Dollar4            => Dollar4[[Ctx0]]
            QuotedBracket4     => QuotedBracket4[[Ctx0]]
            StringQuotedChars4 => StringQuotedChars4[[Ctx0]]
            StringQuotedPart4  => StringQuotedPart4[[Ctx0]]
            Dollar3            => Dollar3[[Ctx0]]
            QuotedBracket3     => QuotedBracket3[[Ctx0]]
            StringQuotedChars3 => StringQuotedChars3[[Ctx0]]
            StringQuotedPart3  => StringQuotedPart3[[Ctx0]]
            Dollar2            => Dollar2[[Ctx0]]
            QuotedBracket2     => QuotedBracket2[[Ctx0]]
            StringQuotedChars2 => StringQuotedChars2[[Ctx0]]
            StringQuotedPart2  => StringQuotedPart2[[Ctx0]]
            Dollar1            => Dollar1[[Ctx0]]
            QuotedBracket1     => QuotedBracket1[[Ctx0]]
            StringQuotedChars1 => StringQuotedChars1[[Ctx0]]
            StringQuotedPart1  => StringQuotedPart1[[Ctx0]]
            StringQuotation    => StringQuotation[[Ctx0]]
            StrChar            => StrChar[[Ctx0]]
            String             => String[[Ctx0]]
            Real               => Real[[Ctx0]]
            Int                => Int[[Ctx0]]
            Keyword            => Keyword[[Ctx0]]
            UCID               => UCID[[Ctx0]]
            LCID               => LCID[[Ctx0]]
            LId                => LId[[Ctx0]]
            Id                 => Id[[Ctx0]]
            ModNamePart        => ModNamePart[[Ctx0]]
            ModName            => ModName[[Ctx0]]
            PreTerm            => PreTerm[[Ctx0]]
            Term               => Term[[Ctx0]]
            StrategyMid        => StrategyMid[[Ctx0]]
            Strategy           => Strategy[[Ctx0]] ]

module RefactoringsService
imports SemanticServices BuildersService

exports
  syntax
    "refactorings" <SectionName-LEX> <LAYOUT?-CF> <SemanticRule*-CF> -> <Section-CF>      {cons("Refactorings")}
    "refactorings"                                                   -> <ReservedName-CF> 

  context-free syntax
    "pp-table" ":" StrategoCall                                            -> SemanticRule {cons("PPTable")}
    "pretty-print" ":" StrategoCall                                        -> SemanticRule {cons("PrettyPrint")}
    "refactoring" SemanticNode* ":" String "=" StrategoCall BuilderOption* -> SemanticRule {cons("Refactoring")}

module BuildersService
imports SemanticServices

exports
  syntax
    "builders" <SectionName-LEX> <LAYOUT?-CF> <SemanticRule*-CF> -> <Section-CF>      {cons("Builders")}
    "builders"                                                   -> <ReservedName-CF> 
    "analysis" <SectionName-LEX> <LAYOUT?-CF> <SemanticRule*-CF> -> <Section-CF>      {cons("Builders"), deprecated("Use 'builders' instead")}
    "analysis"                                                   -> <ReservedName-CF> 

  context-free syntax
    "observer" ":" StrategoCall                          -> SemanticRule  {cons("SemanticObserver")}
    "builder" ":" String "=" StrategoCall BuilderOption* -> SemanticRule  {cons("Builder")}
    "builder" "caption" ":" PropertyValue                -> SemanticRule  {cons("BuilderCaption")}
    "(openeditor)"                                       -> BuilderOption {cons("OpenEditor")}
    "(realtime)"                                         -> BuilderOption {cons("RealTime")}
    "(persistent)"                                       -> BuilderOption {cons("Persistent")}
    "(meta)"                                             -> BuilderOption {cons("Meta")}
    "(cursor)"                                           -> BuilderOption {cons("Cursor")}
    "(source)"                                           -> BuilderOption {cons("Source")}

module CompletionsService
imports SemanticServices

exports
  sorts CompletionPart CompletionAnno

  syntax
    "completions" <SectionName-LEX> <LAYOUT?-CF> <SemanticRule*-CF> -> <Section-CF>      {cons("Completions")}
    "completions"                                                   -> <ReservedName-CF> 

  context-free syntax
    "completion" "proposer" ":" StrategoCall                                              -> SemanticRule     {cons("CompletionProposer")}
    "completion" "lexical" ":" PropertyValue                                              -> SemanticRule     {cons("IdentifierLexical"), deprecated("Use 'identifier lexical' instead")}
    "identifier" "lexical" ":" PropertyValue                                              -> SemanticRule     {cons("IdentifierLexical")}
    "completion" "keyword" ":" PropertyValue OptCompletionAnno                            -> SemanticRule     {cons("CompletionKeyword")}
    "completion" "template" ":" Id CompletionPart+ OptCompletionAnno                      -> SemanticRule     {cons("CompletionTemplate"), avoid, deprecated("Add quotes to the starting literal")}
    "completion" "template" ":" Sort "=" CompletionPart CompletionPart* OptCompletionAnno -> SemanticRule     {cons("CompletionTemplateWithSort"), avoid}
    "completion" "template" Sort* ":" PropertyValue CompletionPart* CompletionAnno*       -> SemanticRule     {cons("CompletionTemplateEx"), recover, avoid}
    "completion" "trigger" ":" PropertyValue OptCompletionAnno                            -> SemanticRule     {cons("CompletionTrigger")}
    "completion" "template" Sort* ":" CompletionPrefix CompletionPart+ CompletionAnno*    -> SemanticRule     {cons("CompletionTemplateEx")}
                                                                                          -> CompletionPrefix {cons("NoCompletionPrefix")}
    String "="                                                                            -> CompletionPrefix {cons("CompletionPrefix")}

  context-free syntax
    "completions"                    -> StrategoCall      {reject}
    "completion"                     -> StrategoCall      {reject}
    "identifier"                     -> StrategoCall      {reject}
    "observer"                       -> StrategoCall      {reject}
    "builder"                        -> StrategoCall      {reject}
    "occurrence"                     -> StrategoCall      {reject}
    ReservedName                     -> StrategoCall      {reject}
    String                           -> CompletionPart    
    Placeholder                      -> CompletionPart    {cons("Placeholder")}
    "(cursor)"                       -> CompletionPart    {cons("Cursor")}
    PlaceholderWithSortPrefix Id ">" -> CompletionPart    {cons("PlaceholderWithSort")}
                                     -> OptCompletionAnno {cons("None")}
    CompletionAnno                   -> OptCompletionAnno 
    "(disabled)"                     -> CompletionAnno    {cons("Disable")}
    "(disable)"                      -> CompletionAnno    {cons("Disable"), deprecated("Use (disabled) instead")}
    "(blank)"                        -> CompletionAnno    {cons("Blank")}
    "(linked)"                       -> CompletionAnno    {cons("Linked")}
    "(blank)"                        -> PropertyValue     {reject}
    "(disable)"                      -> PropertyValue     {reject}
    "(linked)"                       -> PropertyValue     {reject}
    "completion"                     -> PropertyValue     {reject}
    "template"                       -> PropertyValue     {reject}
    "trigger"                        -> PropertyValue     {reject}
    "identifier"                     -> PropertyValue     {reject}

  lexical syntax
    "<" PlaceholderChar* ":" -> PlaceholderWithSortPrefix 
    "<" PlaceholderChar* ">" -> Placeholder               
    ~[\:\>\n]                -> PlaceholderChar           

module ReferencesService
imports SemanticServices

exports
  syntax
    "references" <SectionName-LEX> <LAYOUT?-CF> <SemanticRule*-CF> -> <Section-CF>      {cons("References")}
    "references"                                                   -> <ReservedName-CF> 

  context-free syntax
    "reference" SemanticNode ":" StrategoCall StrategoCall -> SemanticRule {cons("ReferenceHoverRule"), deprecated}
    "reference" SemanticNode ":" StrategoCall              -> SemanticRule {cons("ReferenceRule")}
    "hover" SemanticNode ":" StrategoCall                  -> SemanticRule {cons("HoverRule")}
    "occurrence" SemanticNode ":" StrategoCall             -> SemanticRule {cons("OccurrenceRule")}

  context-free syntax
    "references" -> StrategoCall {reject}
    "reference"  -> StrategoCall {reject}
    "hover"      -> StrategoCall {reject}

module ColorerService
imports Common

exports
  sorts ColorRule Font Color ColorNode MaybeColor NoColor TokenKindName
        AttributeId Attribute

  syntax
    "colorer" <SectionName-LEX> <LAYOUT?-CF> <ColorRule*-CF> -> <Section-CF>      {cons("Colorer")}
    "colorer"                                                -> <ReservedName-CF> 

  context-free syntax
    "environment" ColorNode ":" Attribute            -> ColorRule     {cons("ColorRuleAll")}
    ColorNode ":" Attribute                          -> ColorRule     {cons("ColorRule")}
    "environment" ColorNode ":" String "=" Attribute -> ColorRule     {cons("ColorRuleAllNamed")}
    ColorNode ":" String "=" Attribute               -> ColorRule     {cons("ColorRuleNamed")}
    Color MaybeColor Font                            -> Attribute     {cons("Attribute")}
    AttributeId                                      -> Attribute     {cons("AttributeRef")}
    Node                                             -> ColorNode     
    TokenKindName                                    -> ColorNode     {cons("Token"), prefer}
    "token" Id                                       -> ColorNode     {cons("Literal")}
    "identifier"                                     -> TokenKindName {cons("TK_IDENTIFIER")}
    "number"                                         -> TokenKindName {cons("TK_NUMBER")}
    "layout"                                         -> TokenKindName {cons("TK_LAYOUT")}
    "string"                                         -> TokenKindName {cons("TK_STRING")}
    "keyword"                                        -> TokenKindName {cons("TK_KEYWORD")}
    "operator"                                       -> TokenKindName {cons("TK_OPERATOR")}
    "var"                                            -> TokenKindName {cons("TK_VAR")}
    "error"                                          -> TokenKindName {cons("TK_ERROR")}
    "unknown"                                        -> TokenKindName {cons("TK_UNKNOWN")}
                                                     -> Font          {cons("NORMAL")}
    "bold"                                           -> Font          {cons("BOLD")}
    "italic"                                         -> Font          {cons("ITALIC")}
    "bold" "italic"                                  -> Font          {cons("BOLD_ITALIC")}
    "italic" "bold"                                  -> Font          {cons("BOLD_ITALIC")}
    "_"                                              -> Color         {cons("ColorDefault")}
    Int Int Int                                      -> Color         {cons("ColorRGB")}
                                                     -> NoColor       {cons("NoColor")}
    Color                                            -> MaybeColor    
    NoColor                                          -> MaybeColor    
    AttributeId "=" Attribute                        -> ColorRule     {cons("ColorDef")}
    Id                                               -> AttributeId   
    String                                           -> AttributeId   
    "_"                                              -> AttributeId   {reject}
    Font                                             -> AttributeId   {reject}
    "environment"                                    -> AttributeId   {reject}

module OutlinerService
imports Common

exports
  sorts OutlineRule Pattern Term PreTerm

  syntax
    "outliner" <SectionName-LEX> <LAYOUT?-CF> <OutlineRule*-CF> -> <Section-CF>      {cons("Outliner")}
    "outliner"                                                  -> <ReservedName-CF> 

  context-free syntax
    Node -> OutlineRule {cons("OutlineRule"), prefer}

module FoldingService
imports Common

exports
  sorts FoldingRule FoldingAnno

  syntax
    "folding" <SectionName-LEX> <LAYOUT?-CF> <FoldingRule*-CF> -> <Section-CF>      {cons("Folding")}
    "folding"                                                  -> <ReservedName-CF> 

  context-free syntax
    Node FoldingAnno       -> FoldingRule {cons("FoldRule")}
    "all" Node FoldingAnno -> FoldingRule {cons("FoldRuleAll")}
    "(disable)"            -> FoldingAnno {cons("Disable"), deprecated("Use (disabled) instead")}
    "(disabled)"           -> FoldingAnno {cons("Disable")}
    "(folded)"             -> FoldingAnno {cons("Folded")}
                           -> FoldingAnno {cons("None")}

module SemanticServices
imports Common LanguageDescription

exports
  sorts SemanticRule SemanticNode StrategoId StrategoCall OnSaveAnno

  lexical syntax
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* -> StrategoId   
    "_"                           -> SemanticNode 

  lexical restrictions
    StrategoId -/- [a-zA-Z0-9\'\-\_]

  context-free syntax
    Node                                    -> SemanticNode 
    "provider" PropertyValue                -> SemanticRule {cons("SemanticProvider"), deprecated("Use 'provider :'")}
    "provider" ":" PropertyValue            -> SemanticRule {cons("SemanticProvider")}
    "on" "save" ":" StrategoCall OnSaveAnno -> SemanticRule {cons("OnSave")}
    StrategoId                              -> StrategoCall {cons("Strategy")}
    "id" "." StrategoId                     -> StrategoCall {cons("Attribute")}
                                            -> OnSaveAnno   {cons("None")}

module LanguageDescription
imports Common SemanticServices

exports
  sorts LanguageProperty PropertyValue NoContinuation PropertyValues URL
        FenceDef BlockCommentDef IndentDef

  syntax
    "language" <SectionName-LEX> <LAYOUT?-CF> <LanguageProperty*-CF> -> <Section-CF>      {cons("Language")}
    "language"                                                       -> <ReservedName-CF> 

  lexical syntax
    ~[\ \t\n\r\,\:\"\=]+                  -> PropertyValue {avoid}
    ~[\ \t\n\r\,\/\:]+ "://" ~[\ \t\n\r]+ -> URL           

  lexical restrictions
    PropertyValue -/- ~[\ \t\n\r\,\:\"\=]
    URL -/- ~[\ \t\n\r]

  context-free syntax
    {PropertyValue ","}*                       -> PropertyValues   {cons("Values")}
    String                                     -> PropertyValue    
    "name" ":" PropertyValue                   -> LanguageProperty {cons("LanguageName")}
    "id" ":" PropertyValue                     -> LanguageProperty {cons("LanguageId")}
    "extensions" ":" PropertyValues            -> LanguageProperty {cons("Extensions")}
    "description" ":" PropertyValue            -> LanguageProperty {cons("Description")}
    "table" ":" PropertyValue                  -> LanguageProperty {cons("Table")}
    "table" "provider" ":" StrategoCall        -> LanguageProperty {cons("TableProvider")}
    "start" "symbols" ":" Sort*                -> LanguageProperty {cons("StartSymbols")}
    "start" "symbols" ":" PropertyValues       -> LanguageProperty {cons("StartSymbols"), avoid}
    "url" ":" URL                              -> LanguageProperty {cons("URL")}
    "extends" ":" PropertyValues               -> LanguageProperty {cons("Extends")}
    "aliases" ":" PropertyValues               -> LanguageProperty {cons("Aliases")}
    "unmanaged" "table" ":" Id "*"             -> LanguageProperty {cons("UnmanagedTablePrefix")}
    "disambiguator" ":" StrategoCall           -> LanguageProperty {cons("Disambiguator")}
    "line" "comment" ":" PropertyValue         -> LanguageProperty {cons("LineCommentPrefix")}
    "block" "comment" ":" BlockCommentDef      -> LanguageProperty {cons("BlockCommentDefs")}
    "fences" ":" FenceDef*                     -> LanguageProperty {cons("FenceDefs")}
    "indent" "after" ":" IndentDef*            -> LanguageProperty {cons("IndentDefs")}
    "identifier" "lexical" ":" PropertyValue   -> LanguageProperty {cons("IdentifierLexical")}
    PropertyValue PropertyValue PropertyValue  -> BlockCommentDef  {cons("BlockCommentDef")}
    PropertyValue NoContinuation PropertyValue -> BlockCommentDef  {cons("BlockCommentDef")}
                                               -> NoContinuation   {cons("NoContinuation")}
    PropertyValue PropertyValue                -> FenceDef         {cons("FenceDef")}
    PropertyValue                              -> IndentDef        {cons("IndentDef")}
    "fences"                                   -> PropertyValue    {reject}
    "identifier"                               -> PropertyValue    {reject}
    "indent"                                   -> PropertyValue    {reject}
    "fences"                                   -> PropertyValue    {reject}
    "line"                                     -> PropertyValue    {reject}
    "block"                                    -> PropertyValue    {reject}
    "unmanaged"                                -> Sort             {reject}

module Common
exports
  sorts Id IdStar Int STRING CHAR BACKSLASH String Node Sort Constructor
        ConstructorId ReservedName SectionName ModuleName Section Eof Ws
        ShortCom LongCom CommChar

  lexical syntax
    [a-zA-Z] [a-zA-Z0-9\'\-\_]*     -> Id          
    [a-zA-Z] [a-zA-Z0-9\'\-\_]* "*" -> IdStar      
    "-"? [0-9]+                     -> Int         
    "\"" StringChar* "\""           -> STRING      
    ~[\"\n\\]                       -> StringChar  
    "\\\""                          -> StringChar  
    BACKSLASH                       -> StringChar  
    "\\"                            -> BACKSLASH   
    ~[\n\r]*                        -> SectionName 
    [\t\ \n\r]                      -> Ws          
    "//" ~[\n]* [\n] | Eof          -> ShortCom    
    "/*" CommChar* "*/"             -> LongCom     
    ~[\*]                           -> CommChar    
    Asterisk                        -> CommChar    
    "*"                             -> Asterisk    
    Ws                              -> LAYOUT      
    ShortCom                        -> LAYOUT      
    LongCom                         -> LAYOUT      
                                    -> Eof         

  lexical restrictions
    Int -/- [0-9]
    Id -/- [a-zA-Z0-9\'\-\_]
    SectionName -/- ~[\n\r]
    Asterisk -/- [\/]
    BACKSLASH -/- [\"]
    Eof -/- ~[]

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/] . [\*]
    LAYOUT? -/- [\/] . [\/]

  context-free syntax
    Id                     -> Sort          {cons("Sort")}
    Id "*"                 -> Sort          {cons("ListSort")}
    STRING                 -> String        {cons("String")}
    Sort "." "_"           -> Sort          {bracket}
    "_" "." ConstructorId  -> Constructor   {cons("ConstructorOnly")}
    Id                     -> ConstructorId {cons("Constructor")}
    Sort                   -> Node          
    Constructor            -> Node          
    Sort "." ConstructorId -> Node          {cons("SortAndConstructor")}
    ReservedName           -> Node          {reject}
    ReservedName           -> ModuleName    {reject}

module EditorService
imports Common LanguageDescription FoldingService OutlinerService ColorerService
        ReferencesService CompletionsService BuildersService RefactoringsService

hiddens
  context-free start-symbols
    Module

exports
  sorts Module FileName ModuleName Imports Import

  lexical syntax
    [a-zA-Z0-9\-\_\.]+ -> FileName   
    {FileName "/"}+    -> ModuleName 

  lexical restrictions
    FileName -/- [a-zA-Z0-9\-\_\.]

  context-free syntax
    "module" ModuleName Imports Section* -> Module  {cons("Module")}
    "imports" Import+                    -> Imports {cons("Imports")}
                                         -> Imports {cons("NoImports")}
    ModuleName                           -> Import  {cons("Import")}
    ModuleName "[" Id "]"                -> Import  {cons("ImportRenamed")}

module Stratego-EditorService
imports EditorService StrategoMix[StrategoHost]

exports
  context-free start-symbols
    Module[[StrategoHost]]

  sorts QuotedTerm QuotedTerms

  context-free syntax
    "descriptor" "|[" Module "]|"                         -> Term[[StrategoHost]] {cons("ToMetaExpr")}
    "|[" Module "]|"                                      -> Term[[StrategoHost]] {cons("ToMetaExpr")}
    "descriptor" "|[" OutlineRule "]|"                    -> Term[[StrategoHost]] {cons("ToMetaExpr")}
    "descriptor" "|[" ColorRule "]|"                      -> Term[[StrategoHost]] {cons("ToMetaExpr")}
    "descriptor" "|[" FoldingRule "]|"                    -> Term[[StrategoHost]] {cons("ToMetaExpr"), avoid}
    "descriptor" "|[" SemanticRule "]|"                   -> Term[[StrategoHost]] {cons("ToMetaExpr")}
    "|[" OutlineRule "]|"                                 -> Term[[StrategoHost]] {cons("ToMetaExpr")}
    "|[" ColorRule "]|"                                   -> Term[[StrategoHost]] {cons("ToMetaExpr")}
    "|[" FoldingRule "]|"                                 -> Term[[StrategoHost]] {cons("ToMetaExpr"), avoid}
    "|[" SemanticRule "]|"                                -> Term[[StrategoHost]] {cons("ToMetaExpr")}
    "descriptor" "|[" Section "]|"                        -> Term[[StrategoHost]] {cons("ToMetaExpr")}
    "|[" Section "]|"                                     -> Term[[StrategoHost]] {cons("ToMetaExpr")}
    QuotedTerm                                            -> Id                   {cons("FromMetaExpr"), avoid}
    QuotedTerm                                            -> PropertyValue        {cons("FromMetaExpr"), avoid}
    QuotedTerm                                            -> URL                  {cons("FromMetaExpr"), avoid}
    QuotedTerm                                            -> ModuleName           {cons("FromMetaExpr")}
    QuotedTerm                                            -> Color                {cons("FromMetaExpr")}
    QuotedTerm                                            -> Font                 {cons("FromMetaExpr")}
    QuotedTerm                                            -> SectionName          {cons("FromMetaExpr")}
    QuotedTerm                                            -> SemanticRule         {cons("FromMetaExpr"), avoid}
    QuotedTerm                                            -> Section              {cons("FromMetaExpr")}
    QuotedTerm                                            -> String               {cons("FromMetaExpr")}
    QuotedTerms                                           -> OutlineRule*         {cons("FromMetaExpr")}
    QuotedTerms                                           -> ColorRule*           {cons("FromMetaExpr")}
    QuotedTerms                                           -> FoldingRule*         {cons("FromMetaExpr")}
    QuotedTerms                                           -> PropertyValues       {cons("FromMetaExpr")}
    QuotedTerms                                           -> SemanticRule*        {cons("FromMetaExpr")}
    QuotedTerms                                           -> CompletionPart+      {cons("FromMetaExpr")}
    QuotedTerms                                           -> Section*             {cons("FromMetaExpr")}
    "~" Term[[StrategoHost]]                              -> QuotedTerm           {bracket}
    "~*" Term[[StrategoHost]]                             -> QuotedTerms          {bracket}
    "~sort:" Term[[StrategoHost]]                         -> Sort                 {cons("FromMetaExpr"), prefer}
    "~anno:" Term[[StrategoHost]]                         -> CompletionAnno       {cons("FromMetaExpr"), prefer}
    "<" Strategy[[StrategoHost]] ">" Term[[StrategoHost]] -> QuotedTerm           {cons("App")}
    StrategyAngle[[StrategoHost]]                         -> QuotedTerm           {cons("RootApp"), avoid}

  lexical syntax
    "<" ~[]* ">" -> PropertyValue {reject}
    "~" ~[]*     -> PropertyValue {reject}