module 
	codegen/sdf/to-signature
imports 
	libstratego-sglr
	lib/editor-common.generated
	config
	common
	context/sdf/declare-signature
	context/sdf/declare
	context/-
	codegen/sdf/to-sdf
	include/SpoofaxLang
imports
	codegen/compile
	context/str/parse
	codegen/main
	codegen/generate
	context/signatures
	normalize/signatures
imports 
	utils/path
	utils/debug	
	utils/contract
	
// TODO : generalize several  strategies that are doing a common function 	
rules
	
	to-signature-as-rtree = parse-stratego-string
	
	ensure-valid-generated-signature-relative-path(|project-path):
		m@Module(QName(_)) -> $[[rel-path]
		]
		where 
			rel-path:= $[[<get-generated-signature-relative-path>m]];
			with-spxverify( 
				<file-exists>$[[project-path]/[rel-path].str]
				, !$[ Signature does not exists : [project-path]/[rel-path]]
			)

	get-global-signatures = 
		activate-global-scope(
			<resolve-all-of-current-scope-by-type>OperationDeclaration() => result*
		);
		!result*;
		operation-decl-to-string
	
	
	get-all-enclosed-module-signature =
		verify(?m@Module(QName(_)) | <id> , "Module(QName(_)) @get-all-signatures "); 
		activate-scope(
			<resolve-all-of-current-scope-by-type>OperationDeclaration() => result*
			| m
		);
		! result*;
		operation-decl-to-string
  			 		
rules
	// Temporarily needed  for the lwc project
	// TODO : consider whether we need this rules for spx framework 
	emit-package-signature-main : 
		() -> ()
		where 
			with-spxverify( 
	 			project-path := <ProjectPath>
	 			; Package(package-qname)   := <GetEnclosingPackageName>
	 			; language-name-string			:= <get-main-file-name><GetEnclosingPackageName>
	 			, !" failed to initialize properties e.g., project-path , enclosing package name and language-name string" 
	 		)	 
	 	where 
			debug-compiler(!$[Signature: Generating main signature for the packagees] | <debug-at-linker> , <debug-level-INFO>)
			; <get-enclosed-modules> <GetEnclosingPackageName> => enclosedModules
			; generated-signatures-string := $[module [language-name-string]-signatures 
			 	 imports 
					[<map(
							ensure-valid-generated-signature-relative-path(|project-path))
						>enclosedModules
					]
				 imports 
					[<get-generated-signature-relative-path><get_internal_module_qtname> Package(package-qname)
				  ]
				 imports 
					[$[[<get-autogenerated-artifacts-dir>]/Globals/Signatures]
				  ]	 	 	
			 ]
			; signatures-as-aterm-string := <to-signature-as-rtree >generated-signatures-string
		where
			 autogen-dir := $[[project-path]/include]
		 	; output-path-str 		:=   $[[autogen-dir]/[language-name-string]-signatures.str]
		 	; output-path-rtree 		:= $[[autogen-dir]/[language-name-string]-signatures.rtree]
		 	; <ensure-path-exists>(project-path, "include") 
	   	; chdir-to-project-path 
		where
			<save-to-file>( output-path-str, generated-signatures-string);
			<WriteToBinaryFile>(output-path-rtree, signatures-as-aterm-string);
			<refresh-file>output-path-str;
			<refresh-file>output-path-rtree
		
rules 
		
	// Emits default signatures in Global\ directory 
	emit-default-signatures:
		() -> ()
		where 
			with-spxverify( 
	 			project-path := <ProjectPath>
	 			; sig-file-name := "Globals/Signatures"
	 			; sig-file-rel-path := $[[<get-autogenerated-artifacts-dir>]/[sig-file-name]]
	 			, !"Signature: failed to setup properties e.g., project-path , enclosing package name and language-name string"
 			)
		where 
				debug-compiler(! $[Signature: Generating deafult signatures] | <debug-at-generator> , <debug-level-INFO>)			
			; generated-signatures-string :=  <get-signature-contents(|sig-file-name,"")><get-global-signatures>
			; signatures-as-aterm-string  := <to-signature-as-rtree >generated-signatures-string
		where  
				autogen-dir := $[[project-path]/[<get-autogenerated-artifacts-dir>]]
			; output-path-str 		:=   $[[autogen-dir]/[sig-file-name].str]
			; output-path-rtree 		:= $[[autogen-dir]/[sig-file-name].rtree]
			; <ensure-path-exists>(project-path, $[[<get-autogenerated-artifacts-dir>]/Globals]) 
			; chdir-to-project-path  
		where
				<save-to-file>( output-path-str, generated-signatures-string)
			; <WriteToBinaryFile>(output-path-rtree, signatures-as-aterm-string)
			; <refresh-file>output-path-str
			; <refresh-file>output-path-rtree
			; debug-compiler(! $[ Signature: Finishing generation of default signature] | <debug-at-generator> , <debug-level-INFO>)
	
rules 
	
	get-generated-signature-relative-path :
		Module(qname) -> 	$[[<get-autogenerated-artifacts-dir>]/[<qname-to-path>qname]-signature]
		
	emit-internal-signatures: 
		package-typed-qname@Package(QName(_))  -> <id>
	 	where
	 		with-spxverify(  
	 			project-path := <ProjectPath> 
	 			; root-directory:= $[[project-path]/[<get-autogenerated-artifacts-dir>]]
	 			, ! "Signature: Failed to initialize @emit-internal-signatures "
 			)  
 			; module-typed-qname := <get_internal_module_qtname>package-typed-qname 
 			; !module-typed-qname => Module(module-untyped-qname) 
		  ; !package-typed-qname => Package(package-untyped-qname) 
	    ; modulename-string := <internal_module_name_string>
		where 
			  sig-file-name     :=  <get-signature-file-name><qname-to-path>module-untyped-qname
			; sig-file-rel-path := <get-generated-signature-relative-path>module-typed-qname 
		where 
			debug-compiler(! $[Signature: Generating signature for the following module: [<print-as-string>module-typed-qname]] |<debug-at-generator> , <debug-level-INFO>)			
			; imports-string := $[imports 
				  Globals/Signatures
			  ]
			; generated-signatures-string :=  <get-signature-contents(|sig-file-name,imports-string)> <get-all-enclosed-module-signature> module-typed-qname
			; signatures-as-aterm-string := <to-signature-as-rtree >generated-signatures-string
		where  
			<save-artifact(save-to-file| package-untyped-qname, root-directory, <get-output-path(|"signature", "str")>(root-directory, module-untyped-qname))>generated-signatures-string
			; <save-artifact(
			  	WriteToBinaryFile | 
			  	package-untyped-qname, 
			  	root-directory, 
			  	<get-output-path(|"signature", "rtree")>(root-directory, module-untyped-qname)
			  	)> signatures-as-aterm-string
		  ; debug-compiler(!$[Signature: Finishing generation of Signature for [<print-as-string> module-untyped-qname]] | <debug-at-generator> , <debug-level-INFO>)
			
rules				 
	
	// Emits signatures for the specified module definition		
	emit-signatures:
		m@Module(attrb* , modname , section*) -> m
		where
			with-spxverify (  
	 		   	project-path  := <ProjectPath>
	 			; root-directory:= $[[project-path]/[<get-autogenerated-artifacts-dir>]] 
		  );   
	    with-spxverify (
				  package-typed-qname := <GetEnclosingPackageName>
				; module-typed-qname:= <GetEnclosingModuleName>
				, !$[Signature: Failed to get current context at to-signature.emit-signatures ] 
	  	)  
		where
	   		!module-typed-qname  => Module(module-untyped-qname)
	 		; !package-typed-qname => Package(package-untyped-qname)
			; !modname => SPXModuleName(modulename-string)
			; sig-file-name     :=  <get-signature-file-name><qname-to-path>module-untyped-qname
			; sig-file-rel-path :=  <get-generated-signature-relative-path>module-typed-qname
		where 
			  debug-compiler(!$[Codegen| SDF | Generating signature for the following module: [<print-as-string>module-typed-qname]])			
			; imports-string := $[imports 
				  Globals/Signatures
			  ]
			; generated-signatures-string :=  <get-signature-contents(|sig-file-name,imports-string)> <get-all-enclosed-module-signature> module-typed-qname
			; signatures-as-aterm-string  :=  <to-signature-as-rtree >generated-signatures-string
		where  
			with-spxverify(
			 <save-artifact(
					save-to-file| 
					package-untyped-qname, 
					root-directory, 
					<get-output-path(|"signature", "str")>(root-directory, module-untyped-qname))> generated-signatures-string;
	
			  <save-artifact(
			  	WriteToBinaryFile| 
			  	package-untyped-qname, 
			  	root-directory, 
			  	<get-output-path(|"signature", "rtree")>(root-directory, module-untyped-qname))> signatures-as-aterm-string
  		  , !$[Saving [<get-output-path(|"signature", "str")>(root-directory, module-untyped-qname)] failed]	
	  	)
			; debug-compiler(!$[Signature: Finishing generation of Signature for [<print-as-string> module-untyped-qname]] | <debug-at-generator> , <debug-level-INFO>)
			
	
rules 

	// TODO: use concrete syntax for signatures?
	
	// Instead of using String interpolation, Generate the default signatures
	// using global contructor defined during init-declartion   
	
	// TODO : OPTMIZE : add a pretty printer to convert operation name DR to STR Signatures. 
	// Currently , using string interpolation, signature are generated . then it is reparsed to
	// to convert it to aterm. Get rid of this. 
	
	get-signature-contents(|moduleName,imports): signatures-string* ->
$[module [moduleName]

[imports]
signature
    constructors
       [<concat-strings>signatures-string*]
]  
	
  operation-decl-to-string : [] -> []
  
  operation-decl-to-string : 
  	[first-op-decl | rest-op-decl* ]->[current-op-decl-string | rest-op-decl-string*]
  	where 
  		(opname, operands*, resultant-sort) := first-op-decl
  		;if (!operands* => []) then
	  		current-op-decl-string := $[[<opname-to-string>opname]: [resultant-sort]
	  		]
  		else
  			current-op-decl-string := $[[<opname-to-string>opname]: [<lhs-operands-to-string>operands*] -> [resultant-sort]
  			]
  		end		 
  		;rest-op-decl-string* := <operation-decl-to-string> rest-op-decl* 
 	
 	
 	opname-to-string : 
 		opname -> opname-string
	 	where 
	 		if (!opname => "") then opname-string := $[]
			else opname-string  := opname
			end
					
  //TODO : generalize following strategies. 
  lhs-operands-to-string : [] -> $[]
  
  lhs-operands-to-string : [last] -> $[[last]]
   
  lhs-operands-to-string : 
  	[hd-operand|rest*] -> $[[hd-operand-string] * [rest-operand-string]]
  	where
  		not (!rest* => []) 
  		; hd-operand-string := hd-operand 
	  	; rest-operand-string := <lhs-operands-to-string>rest*
  	  