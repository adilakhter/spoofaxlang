module codegen/sdf/to-sdf

imports
  libstratego-lib
  libstratego-gpp
  libstratego-sglr
  libstratego-sdf
imports
	include/SpoofaxLang
	lib/editor-common.generated
  lib/sdf-desugar
  lib/sdf-parenthesize
imports
	context/-
	context/sdf/declare
imports
  normalize/main
	normalize/signatures
	normalize/templatelang
imports
	common
	config
	utils/annotations
	utils/attributes
	utils/path
	utils/debug
imports
	codegen/main
	codegen/generate
	codegen/template/to-sdf 
	utils/contract
	utils/sdf2conflicts

rules
	emit-sdf:
 		Module(attrb* , modname , section*) -> <id>
 		where	with-spxverify(
 						project-path := <ProjectPath>
 						; package-typed-qname := <GetEnclosingPackageName>
						; module-typed-qname  := <GetEnclosingModuleName>
						, !"Failed to create current scope at to-sdf.emit-sdf"
					)	
		where	!module-typed-qname  => Module(module-untyped-qname)
			 		; !package-typed-qname => Package(package-untyped-qname)
			 		;  Module(_, _ , section') := <get-desugared-module-ast>module-typed-qname
		where	root-directory := $[[project-path]/[<get-autogenerated-artifacts-dir>]]
   				; output-path   := <get-output-path(|"sdf")>(root-directory , module-untyped-qname)
    where	sdf-string := <pp-sdf-string'> 'module( // sdf2conflicts here collects information for the parenthesation in the prettyprinter
    																		<qname-to-path>module-untyped-qname, 
    																		<to-sdf-imports-block>section* , 
    																		//<to-sdf-section-block;sdf2conflicts-store-sdf>section* 
    																		<to-sdf-section-block>section*
    																		)
    			; <save-artifact(| package-untyped-qname , root-directory, output-path)>sdf-string 
					; debug-compiler(!$[SDF: Finishing generation of SDF for [<print-as-string> module-untyped-qname]. ] | <debug-at-generator> , <debug-level-INFO>)

	
	
rules	
	generate-sdf-main:  
		module-qname* -> <id>
		where Package(package-qname)   := <GetEnclosingPackageName>
		where debug-compiler(!$[SDF: Generating main failed for the following package : [<print-as-string> package-qname].] | <debug-at-linker> , <debug-level-INFO>)
		where 		
			with-spxverify(
		 			project-path             := <ProjectPath> 
 			 		; relative-autogen-path :=  <qname-to-path>package-qname
 			 		; autogen-dir :=$[[<get-autogenerated-artifacts-dir>]/[relative-autogen-path]]
			 		; root-directory := $[[project-path]/[<get-autogenerated-artifacts-dir>]]
			 		; main-sdf-module-name :=<get-main-file-name><GetEnclosingPackageName> 
			 		; output-path := <get-main-output-path(|main-sdf-module-name, "sdf")>(root-directory, package-qname) 
			 		, ! $[SDF : Generating main failed for the following package : [<print-as-string> package-qname].]
			)  
			; with-spxverify(
	 				resultant-sorts := <get-sdf-start-symbols-to-sync ; is-not-empty-list <+ ![]>;
	 				if not(!resultant-sorts => []) then
		 				start-symbol-syntax := [exports(context-free-start-symbols(resultant-sorts))]
	 				else	
	 					start-symbol-syntax := []
	 				end
	 				, !"getting & syncing start symbols failed"
				)
 		where
 			sdf-string :=
				<pp-sdf-string'>
				'module(
  				unparameterized(main-sdf-module-name)
					, [imports(<map(pp-sdf-import;!'module(unparameterized(<id>)))>module-qname*)]
					, start-symbol-syntax
					)
	  	; with-spxverify(
					<save-artifact(| package-qname , root-directory, output-path)>sdf-string
					, ! $[Save failed for Main SDF Module of package : [<print-as-string> package-qname]]
				)	
			
rules

	to-sdf-section-block : 
		sections* -> sdf-section-block
		where with-spxverify(verify( List |sections* , "List expected"))
		where	sdf-section* := <conc;flatten-list> (
			  		<collect-om(?SDFSection(<id>) + ?SDFSectionEH(_, <id>), conc) > sections*,
			  		<collect-om(?TemplateSection(_))    ; template-sections-to-sdf> sections*,
			  		<collect-om(?KeywordSection(_,_,_)) ; keyword-sections-to-sdf > sections*
					);
					if <ensure-list-is-not-empty>sdf-section* then
						sdf-section-block := <to-generated-artifact-block(desugar-spxsdf-to-sdf , \s -> [exports(s)]\)>sdf-section*
					else
						sdf-section-block := []
					end


	to-sdf-imports-block : 
		sections*  -> sdf-import-block
		where with-spxverify(	verify( List |sections* , "List expected"))
		where	spx-import-stmt* := <collect-om(?Imports(<id>) , conc);flatten-list;make-set> sections*;
					if <ensure-list-is-not-empty>spx-import-stmt*  then
						sdf-import-block := <to-generated-artifact-block(to-generated-artifacts-import-declarations(to-sdf-import-statement), \s -> ['imports(s)]\)>spx-import-stmt*
					else
						sdf-import-block := []
					end
					

 	// Resolved Imports are alraedy filtered out in the previous step.
 	// Hence, native spx imports are added without any further
 	// verifications.
 	to-sdf-import-statement: 
 		name  -> 	'module(unparameterized(name))
 		where	is-string
	
	to-sdf-import-statement:
		p@Package(QName(_)) -> r 
		where	to-sdf-mix-module-name => mix-module-name  
		where	with-spxverify( 
							ctx := <get-imported-package-alias> (<GetEnclosingPackageName>,p) 
						, !$[Failed to get alias for package [<print-as-string>p] in [<print-as-string><GetEnclosingPackageName>]] 
				  )
		where r := 'module(parameterized(mix-module-name, [sort(ctx)]))
						  
	to-sdf-import-statement:
			Module(q@QName(_)) -> result
			where !q  
						;	qname-to-path  
						;	to-sdf-import-statement  
						;	?result  
			
	// Additional verification is done during importing legacy artifacts.
	// Here, both Unresolved libraries and Stratego Libs are Ignored.
	// Basically anything Unresolved is not added as a import statment in
	// generated SDF definition.
 	to-sdf-import-statement : 
 		legacy-artifact@Name(name)  -> 	result
	 	where	if <has-extension(|"sdf")+has-extension(|"def")><get-enclosed-legacy-artifact-details> then
						// Importing Legacy artifact only if it is a SDF or DEF file
						// Assumption : resolved global imports refers to stratego lib and declared in global scope.
						result :=  'module(unparameterized(name)) ;
						<record-def-import-reference>name
					else
						result :=  []
					end

	// Recoding references of def file so that we can specify -Idef arguments in pack-sdf
	// It would have been much cleaner if Pack-SDF by defult supports it without specifying this extra arguments.
	record-def-import-reference =
		where(		
			?qualified-def-name;
			// Verifying whether it is indeed a def file.
			if (<has-extension(|"def")> <get-enclosed-legacy-artifact-details>) then
				package-typed-qname := <GetEnclosingPackageName> ;
				<index-imported-def-of-package>(package-typed-qname  ,qualified-def-name) 
			end
		)

rules

	override pp-sdf-string = fail // ensure compiler doesn't blow up

  pp-sdf-string' =
    sdf-desugar;
    parenthesize-Sdf2;
  	sdf-ppfix;
    ast2box(|[<pp-table-sdf>]);
    box2text-string(|80)

rules
	desugar-spxsdf-to-sdf = list-to-conc-grammars; topdown(repeat(desugar-sdf-redux)) ; alltd(to-sdf-sort)

  // TODO: also support Constructor("Module(<2>, <1>)") => {ast("...")}?
  //desugar-sdf-redux:
  //  term(default(fun(quoted(s)))) -> term(default(appl(unquoted("cons"), [fun(quoted(s))])))
  desugar-sdf-redux:  Constructor(s) -> sdf-cons(s)

  // HACK: remove scope from output
  desugar-sdf-redux: term(default(appl(unquoted("scope"), [s]))) ->  term(default(appl(unquoted("scope"), [])))

  desugar-sdf-redux: namespacedef(_, s) -> s

  desugar-sdf-redux: namespaceref(n) -> sort(s') where  s' := < resolve-NamespaceSort-declaration <+ !"ID"> n

  desugar-sdf-redux: namespaceref2(n, s) -> s
				
rules
  list-to-conc-grammars: [g1, g2 | gs] -> conc-grammars(g1, <list-to-conc-grammars> [g2 | gs])

  list-to-conc-grammars: [g1] -> g1

  list-to-conc-grammars: [] -> []

rules

	//pretty printing as sdf imports
	pp-sdf-import: 
		Module(q@QName(qnameparts*))-> result
		where
				result := $[[<qname-to-path >q]
									 ]
rules

  // (from TemplateLang)

  // Allows one to write `Sort.Cons' where a production is expected.
  // (i.e. in priority sections)

  desugar-sdf-redux:
    simple-ref-group(ref) -> simple-group(<SortCons-to-prod> ref)

  desugar-sdf-redux:
    prods-ref-group(ref*) -> prods-group(<map(SortCons-to-prod)> ref*)

  desugar-sdf-redux:
    assoc-ref-group(a, ref*) -> assoc-group(a, <map(SortCons-to-prod)> ref*)

  SortCons-to-prod:
    SortCons(sort, cons) -> t
    where 
    	with-spxverify(
				<(  resolve-atleast-one-sdf-declaration <+  
  		 	 	  debug(!"Undeclared SortCons"); 
    		 	  debug(!"all-keys-Declaration is not available"); 
    		 	  fail
    		 	)
				  ; try(template-production-to-sdf-no-attrs)
		   >(sort, cons) => t 
			)
  
  // Hook desugar-sdf-redux to templatelang-desugar-sdf
  desugar-sdf-redux = templatelang-desugar-sdf
  

rules 
	
	to-sdf-mix-module-name: 
		Package(q@QName(_)) ->  mod-name
		where !q 
					; QName(at-last([<conc-strings>(<id>, "-Mix")]))
					; qname-to-string   
					; ?mod-name   
	
	
	generate-sdf-mix-main: 
		Package(QName(_)) -> <id>
		where debug-compiler(!$[SDF: Generating SDF MIX for the following package : [<print-as-string>])] | <debug-at-linker> , <debug-level-INFO>)
		where 	get-enclosed-modules
					;	generate-sdf-mix-main
				 	
	
	generate-sdf-mix-main:  
		module-qname* -> <id>
		where is-list 
		where Package(package-qname)   := <GetEnclosingPackageName>
		where debug-compiler(!$[SDF: Generating SDF MIX for the following module : [<print-as-string>module-qname* ])] | <debug-at-linker> , <debug-level-INFO>)
		where 		
			with-spxverify(
		 			project-path             := <ProjectPath> 
 			 		; relative-autogen-path  :=  <qname-to-path>package-qname
 			 		; autogen-dir            := $[[<get-autogenerated-artifacts-dir>]/[relative-autogen-path]]
			 		; root-directory         := $[[project-path]/[<get-autogenerated-artifacts-dir>]]
			 		; sdf-mix-module-name    := <to-sdf-mix-module-name>Package(package-qname) 
			 		; output-path            := <get-main-output-path(|sdf-mix-module-name , "sdf")>(root-directory, package-qname)
			 		     
			 		, ! $[SDF: Generating main failed for the following package : [<print-as-string> package-qname]]
			)  
		where mix-context :=  <newname>"Ctx";
					!'module(
								parameterized(sdf-mix-module-name, [sort(mix-context)])
							, <filter(to-sdf-mix(|mix-context))>module-qname*
							, []
						);
					pp-sdf-string'; 
					with-spxverify(save-artifact(|package-qname , root-directory, output-path)
													, ! $[Save failed for SDF MIX of package : [<print-as-string> package-qname]]
												)	
		
	to-sdf-mix(| mix-context) =  
		?m@Module(QName(_));
		<pp-sdf-import>m => sdf-import-path;
		activate-scope(<resolve-all-of-current-scope-by-type> SortDeclaration() | m);
		where(is-not-empty-list);
		nub;
		!'imports(
				[	renamed-module(
          		unparameterized(sdf-import-path)
      			, renamings(
            		<map(to-sdf-mix(|mix-context))>
          		)
        		)
				]
			)	

	to-sdf-mix(|mix-context) = 
		?(sortName ,_);
		!symbol(sort(sortName), parameterized-sort(sortName, [sort(mix-context)]))
		
rules

	to-sdf-sort: prod(lhs, sort, attrs) -> prod(lhs', sort, attrs) where lhs' := <alltd(to-sdf-sort)>lhs

  to-sdf-sort: QualifiedSort(Unresolved(), x) -> sort(x)

  to-sdf-sort: 
  	q@QualifiedSort(p@Package(QName(_)), x) -> sort'
  	where <get-sdf-usage(|p)>x;
  				<get-imported-package-alias>(<GetEnclosingPackageName>, p) => ctx;
  				sort' := parameterized-sort(x, [sort(ctx)])
			<+
  				sort' := sort(x)	 
  	
  to-sdf-sort: 
  	sort(x) -> sort'  
  	where  
  		(s,c,t) := <get-sdf-usage(|Unqualified())>x;
  		?(_, _, PublicScope());
  	  if <?Module(QName(_))>c then 
				ns:=<get-enclosing-package-qname>c
			else 
				ns := c
			end;		  
			ctx := <get-imported-package-alias>(<GetEnclosingPackageName>, ns);  
		  sort' := parameterized-sort(x, [sort(ctx)])
		<+
			sort' := sort(x) 		
			
rules 
 	
	keyword-sections-to-sdf:
 		keyword-sections -> sdf-sections 
 		where <mapconcat(keyword-sections-to-sdf)>keyword-sections => sdf-sections 
 	
 	keyword-sections-to-sdf:	 
 			<is-string> -> lit(x)
 			where x := <concat-strings>[ "\"" , <id> , "\""]

	keyword-sections-to-sdf:
		(id-sort , literals*) -> lexical-syntax(prod*) 
		where ?(_ , <is-list>)
		where prod* := <map(<keyword-sections-to-sdf>(id-sort , <id>) )>literals*
	
	keyword-sections-to-sdf:
		(id-sort , l@lit(x)) -> prod([l], id-sort, attrs([reject()]))
	
	keyword-sections-to-sdf: 
		KeywordSection(KeywordSymbols(s*) , Keywords(w*), Some(FollowRestriction(restriction))) -> sdf-section*  
		where literals* := <map(keyword-sections-to-sdf)>w*
		where sorts*    := <map(to-sdf-sort)>s*     
		where to-sdf-restriction-section:=
						lexical-restrictions(
							[ follow(
						 				literals*
						 			,	restriction
						 	 	)	
							]
						) 
					;	<map(<keyword-sections-to-sdf>(<id>, literals*))>sorts* => to-sdf-keyword-prouction-sections*
					; <conc>( [to-sdf-restriction-section] , [to-sdf-keyword-prouction-sections*]) => sdf-section* 
					 				