module codegen/str/to-stratego
imports
	libstrc
imports
  libstratego-lib
	lib/editor-common.generated
imports
  include/SpoofaxLang
imports
	common
	config
	utils/debug
	utils/path
	utils/annotations
imports
	codegen/compile
  codegen/generate
	codegen/main
	codegen/sdf/to-name-analysis
  codegen/sdf/to-signature
	codegen/template/to-str
imports
	context/-
imports
	normalize/signatures
	utils/contract
	utils/sdf2conflicts
	common


rules
	// emit STR definition for the specified SPX module.
 	emit-str:
		m@Module(attrb* , modname , section*) -> m
		where
			with-spxverify(
	 			 project-path := <ProjectPath>
	 			 ; root-dir := $[[project-path]/[<get-autogenerated-artifacts-dir>]]
	 			 ; package-typed-qname := <GetEnclosingPackageName>
				 ; module-typed-qname  := <GetEnclosingModuleName>
				 , !$[emit-str : Failed to create current scope.]
			)	   
		where
	 		!module-typed-qname  => Module(module-untyped-qname)
			; !package-typed-qname => Package(package-untyped-qname)
		 	; !modname             => SPXModuleName(modulename-string)
		 	; debug-compiler(!$[Stratego: generating code for the following module : [<print-as-string>module-untyped-qname]] | <debug-at-generator> , <debug-level-INFO>)
		where
			emit-str-rtree(| package-untyped-qname, module-untyped-qname, root-dir)
			; emit-str-concrte-syntax (|package-untyped-qname, module-untyped-qname, root-dir)
	 	  ; debug-compiler(!$[Stratego: finishing generation of following module: [<print-as-string> module-untyped-qname].]| <debug-at-generator> , <debug-level-INFO>)


	// emit stratego concrete syntax
	emit-str-concrte-syntax(| package-untyped-qname, module-untyped-qname , root-dir) :
		str-rtree -> str-concrete-syntax
		where	output-path-str 	    := <get-output-path(|"str")>(root-dir, module-untyped-qname)
   				; str-concrete-syntax := <to-str-string>str-rtree
					; <save-artifact(|package-untyped-qname, root-dir,output-path-str)> str-concrete-syntax

	// emit stratego rtree
	emit-str-rtree(|package-untyped-qname, module-untyped-qname , root-dir):
		Module(attrb* , modname , section*) -> str-aterm
		where
			with-spxverify(
				output-path-rtree    := <get-output-path(|"rtree")>(root-dir, module-untyped-qname)
				, ! "emit-str-rtree: failed to get output-path-rtree @emit-str-rtree"
			)
			// TODO FIX : enable name analysis. currently it is not fully supported  
			//; str-section-def := <conc>(<collect-om(?STRSection(<id>), conc)> section* ,<get-name-analysis>section*)
			; str-section-def := <collect-om(?STRSection(<id>), conc)> section* 
			; str-aterm := Module(
			 										 <qname-to-path>module-untyped-qname,
			 										 <conc>(<to-str-imports-block(|module-untyped-qname)>section*,
			 											  		str-section-def
			 													 )
			 										)
			; <save-artifact(WriteToBinaryFile | package-untyped-qname, root-dir,output-path-rtree)> str-aterm

rules
	// Generates main stratego module for the specified package-name
	generate-str-main:  
		module-qname* -> <id>
		where	with-spxverify(
							project-path             := <ProjectPath>
 			 			; Package(package-qname)   := <GetEnclosingPackageName>
 			 			; root-directory 					:= $[[project-path]/[<get-autogenerated-artifacts-dir>]]
 		  		)
		where	debug-compiler(!$[Stratego: Generate-str-main from package-name: [<print-as-string>package-qname]] | <debug-at-linker> , <debug-level-INFO> )
		where	with-spxverify(
	 			 			main-str-module-name :=  <get-main-file-name><GetEnclosingPackageName>;
	       			module-imports := Imports(<get-str-imports(|<GetEnclosingPackageName>)>module-qname*);
	       			if templatelang-enabled then 
	       				pp-module-name := <conc-strings>(main-str-module-name, "-prettyprinter");
	       				all-import* := [module-imports, Imports([Import(pp-module-name)])] 
				 			else 
				 				pp-module-name := "";
				 				all-import* := [module-imports ]
				 			end
				 			;	str-aterm := Module(main-str-module-name, all-import*)
	 			 		; str-string := <pp-stratego-string> <parenthesize-Stratego> str-aterm
		    	)
		  		; with-spxverify(
			 			  <save-artifact(save-to-file      | package-qname , root-directory, <get-main-output-path(|main-str-module-name, "str")>(root-directory, package-qname))>str-string
						; <save-artifact(WriteToBinaryFile | package-qname , root-directory, <get-main-output-path(|main-str-module-name, "rtree")>(root-directory, package-qname))>str-aterm
		  			)
					; debug-compiler(!$[Stratego: Generation of Main STR Module for package : [<print-as-string> package-qname] is done] | <debug-at-linker> , <debug-level-INFO> )
					where <generate-str-templates-main>(package-qname , module-qname* , pp-module-name, root-directory)
		

	// Generating pretty-printer if templatelang is enabled 
	generate-str-templates-main = 					
			?(package-qname , module-qname* , pp-module-name, root-directory); 
			if templatelang-enabled then    
		 			with-spxverify(
		    		debug-compiler(!$[Stratego: Generating prettyprinter from package-name: [<print-as-string> package-qname]] | <debug-at-linker> , <debug-level-INFO> );
			    	{|SubtermConflicts:
					      <sdf2conflicts> []
				      // HACK: this lacks any sanity wrt the original modules in which the SDF was placed ...
				      ; section* := <map(get-original-module-definition; ?Module(_, _, <id>)); concat> module-qname*
		  	      ; section'* := <filter(?SDFSection(_) + ?SDFSectionEH(_, _) + ?TemplateSection(_))> section*
		    	    ; activate-internal-scope(  
		        			// this uses information collected by sdf2conflicts
			      	  	pp-aterm := <template-sections-to-stratego> section'*
				        )  
			   	 |}
	  	     ; pp-string := <pp-stratego-string> <parenthesize-Stratego> pp-aterm
		  	   ; pp-qname := <QName(at-last([<conc-strings>(<id>, "-prettyprinter")]))> package-qname
		    	 ; <save-artifact(save-to-file      | pp-qname , root-directory, <get-main-output-path(|pp-module-name, "str")>(root-directory, pp-qname))> pp-string
		    	 ; <save-artifact(WriteToBinaryFile | pp-qname , root-directory, <get-main-output-path(|pp-module-name, "rtree")>(root-directory, pp-qname))> pp-aterm
		   		 ; debug-compiler(!$[Stratego: Generation of prettyprinter : [<print-as-string>package-qname] is done.] | <debug-at-linker> , <debug-level-INFO>)
					)
				end
rules

	// get name analysis for  the specified sections
	get-name-analysis :  
		sections* -> result
		where	sdf-section* := <collect-om(?SDFSection(<id>) + ?SDFSectionEH(_, <id>), conc)>sections*;
					Module(_, result) := <generate-name-analysis>sdf-section*
				<+
					debug-compiler(!$[Failed name analysis.] |  <debug-at-generator> , <debug-level-ERROR>) 

rules

	to-str-string: 
		sections* -> str-section-block
		where
			str-section-block := <parenthesize-Stratego; pp-stratego-string>sections*

	to-str-imports-block(|module-qname): 
		sections*  ->str-import-block
		where
			with-spxverify(
					verify( is-list |sections* , "expected List")
				; verify( ?QName(_)|module-qname , "expected:QName(_)")
				, !"to-str-imports-block failed in contracts validations" 
			)
			; spx-import-stmt* := <collect-om(?Imports(<id>) , conc);flatten-list;make-set> sections*;
			if <ensure-list-is-not-empty>spx-import-stmt*  then
				str-import-block' := <to-generated-artifact-block(to-generated-artifacts-import-declarations(to-str-import), \s -> [Imports(s)]\)>spx-import-stmt*
			else
				str-import-block' := []
			end;
			module-qualified-path := <qname-to-path>module-qname ;
			str-import-block := <flatten-list>[[Imports([Import(<get-signature-file-name>module-qualified-path)])], str-import-block']


rules

	// Returns the import statements for this package.
	// In addition, it imports Internal Signatures for this package
	// And by default add reference to libstratego-lib
	get-str-imports(|package-qname): 
		module-qnames* -> result
		where
			result' := <map(to-str-import);flatten-list>module-qnames*
		where
			<to-str-import><get_internal_module_qtname>package-qname => [_, sig-import];
			result := <conc>([Import("libstratego-lib"),sig-import] , result')

rules

	to-str-import :
		Package(QName(_)) -> result 
		where get-enclosed-modules
					;	map(?Module(<id>) ; qname-to-path ; to-str-import)
					; ?result 	 
			
	to-str-import:
		package-name -> [Import(package-name) , Import(<get-signature-file-name>package-name)]
		where
			<is-string>package-name

	to-str-import:
		legacy-artifact@Name(name)  -> 	result
 		where
			if(
				<is-declared-legacy-artifact> name
			<+
				<has-extension(|"str")+	has-extension(|"rtree")><get-enclosed-legacy-artifact-details>
			)
			then
				// Importing legacy artifact. Please note that , for legacy artifact, signatrue is not included
				// as it is taken care of during signature generation of _Internal module for every package.
				result :=  [Import(name)]
			else
				result :=  []
			end

	to-str-import:
		Module(q@QName(qnameparts*))->[Import(str-import),Import(sig-import)]
		where
			str-import:= <qname-to-path>q;
			sig-import:= <get-signature-file-name>str-import
