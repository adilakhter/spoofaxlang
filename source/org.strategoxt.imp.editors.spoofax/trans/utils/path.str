module utils/path 
imports 
	lib/editor-common.generated 
	context/signatures
	codegen/generate
imports
	common
	config
	utils/debug
	include/SpoofaxLang
	spoofaxlang
	normalize/signatures

rules 
	get-normalized-path = string-replace(|"\\", "/")		
	
	is-equal-path(|path1): path2 -> <id>
		where is-string 
		where !(<get-normalized-path; explode-string>path1  , <get-normalized-path; explode-string> path2)
  				;	strcasecmp  
  				;	?0		
rules 
	
	has-known-extensions  =
		?file-path ;
		get-known-legacy-extensions;
		filter({ext : ?ext; <has-extension(|ext)>file-path});
		is-not-empty-list;
		!file-path
	<+
		<debug> $[ERROR::  Unknown File Type found at :[<print-as-string>] . Supported File Extensions are : [<get-known-legacy-extensions;print-as-string>]];
		fail
		

rules 
	
	qname-to-string-as-qualified-path = convert-qname(|".")
	 
	qname-to-path = 	convert-qname(|"/")
	
	qname-to-string =	 convert-qname(|"-")
	
	package-qname-to-string =  ?Package(QName(<id>)) ; convert-qname(|".") 
		 	
	convert-qname(|seperator) =
		?QName(qname-parts*)
		;<separate-by(|seperator);concat-strings>qname-parts*

	convert-qname(|seperator) =
		?Name(name)
		; !name

rules

	get-output-path(|prefix, extension)= 
		?(dir-path, QName(qname-parts*))
		;if not(!qname-parts* => []) then 
				relative-path := <qname-to-path> QName(qname-parts*)
				;<concat-strings> [dir-path, "/" , relative-path ,"-", prefix, "." , extension]
		else
			!dir-path// there is no point of concat relative-path if its empty
		end
		
	get-output-path(|extension)= 
		?(dir-path, QName(qname-parts*))
		;if not(!qname-parts* => []) then 
				relative-path := <qname-to-path> QName(qname-parts*)
				;<concat-strings> [dir-path, "/" , relative-path , "." , extension]
		else
			!dir-path// there is no point of concat relative-path if its empty
		end 
	
	get-main-file-name =
		?QName(qname-parts*);
		<convert-qname(|"-")>QName(qname-parts*) => qname-as-string;
		<concat-strings>[qname-as-string]
	
	get-signature-file-name = 
		?sdf-module-name;
		<concat-strings>[sdf-module-name,"-signature"]
	
	get-main-output-path(|main-file-name, extension)=
		?(dir-path, QName(qname-parts*))
	 	;	<concat-strings> [dir-path, "/" ,main-file-name, "." , extension]  
		 		
	get-main-output-path(|extension)=
		?(dir-path, QName(qname-parts*))
		 ;artifact-main-file-name    := <get-main-file-name>QName(qname-parts*)
		 ;<concat-strings> [dir-path, "/" ,artifact-main-file-name, "." , extension]  
	
	
	append-if-not-empty(|string-to-append, seperator) : 
		operand ->result
  	where 
  		if <eq>("", string-to-append) then 
				result := operand
			else
				result := $[[string-to-append][seperator][operand]]//TODO : when there is a concept-name added in spx , result will be package-name/conceptname
			end 
		
rules
	
	ensure-exists =  
		?(autogen-root-path, QName(qname-parts*))
		;<ensure-directory-exists>autogen-root-path 
		;if not(<eq>(<length>qname-parts*,0)) then 
				<map(create-folder)>qname-parts*  //Creating sub-directories from the qname parts 
		 end
		;create-folder(|autogen-root-path)  // restoring current folder to the project-path 
	
	//ensures whether a particular directory exists. If it does not , then creates a new one with the same name. 	
	ensure-directory-exists = ?dirpath ; ((file-exists ; filemode ; isdir) <+ mkdir); chdir	

	ensure-path-exists =  
		?(project-path,relative-path)
		;<is-string>relative-path
		;dir* := <string-tokenize> (['/'], relative-path) //tokenize relative-path to create the subdirectories
		;if not(<eq>(<length>dir*,0)) then 
				<map(create-folder)> dir*  //Creating sub-directories if they does not exists
		 end
		;create-folder(|project-path)  // restoring current folder to the project-path 
	
	
	create-folder(|directory-to-create) = <file-exists<+mkdir(|"w")> directory-to-create;<chdir>directory-to-create  
	
  create-folder: 
  	folder-name -> None() 
		where with-spxverify(
    	<file-exists<+mkdir(|"w")> folder-name 
      ;<chdir>folder-name
   	) 		    
  
  chdir-to-project-path =  
  <chdir><get-project-path>   

rules 
	spx-precompiled-cache-path = 
		spx-cache-path(|"precompiled.sig")
	
	spx-lib-cache-path = 
		spx-cache-path(|"libs.sig")
	
	
	spx-semantic-issues-cache-path = 
		spx-cache-path(|"err")
		
	spx-cache-path(|extension-prefix):
    full-path -> cache-path
    where 
    	with-spxverify(
	      project-path := <get-project-path>;
	      cache-dir    := <file-exists <+ mkdir> $[[project-path]/.spxcache];
	      full-path'   := <string-replace(|"/", "+"); string-replace(|"\\", "+"); string-replace(|":", "+")> full-path;
	      cache-path   := $[[cache-dir]/[full-path'].[extension-prefix]]
    	)
	
	spx-compilation-unit-path = where(is-string); abspath
		
rules 
	resolve-legacy-import-path(|sourcedir) =
		 where (is-string);
		 try-resolve-as-sdf(|sourcedir )
	<+ try-resolve-as-str(|sourcedir )
	<+ try-resolve-as-esv(|sourcedir )
	<+ 
		 debug-compiler(! $[resolve-legacy-import-path|Failed to resolve import path for : [<print-as-string>]] | "resolve-legacy-import-path" , <debug-level-INFO>)
		 ; !Unresolved() 
	
			
	try-resolve-as-str(|source-dir) = 
		?importname; 
		where (
			full-path := <resolve-import-path'(|source-dir)> $[[importname].str]
  	<+
  		full-path := <resolve-import-path'(|source-dir)> $[[importname].rtree]
		);
		!full-path
	
	
	try-resolve-as-sdf(|source-dir) = 
		?importname; 
		where (
			full-path := <resolve-import-path'(|source-dir)> $[[importname].sdf]
  	<+
  		full-path := <resolve-import-path'(|source-dir)> $[[importname].def]
		);
		!full-path
		
		
	try-resolve-as-esv(|source-dir) = 
		fail
	
	//TODO refactor : fetch the folders from the config.str 
	resolve-import-path'(|source-dir):
  x -> full-path
  where
  	full-path := <file-exists> $[[source-dir]/[x]]
 <+ full-path := <file-exists> $[[<get-project-path>]/[x]]
 <+ full-path := <file-exists> $[[<get-project-path>]/trans/[x]]
 <+ full-path := <file-exists> $[[<get-project-path>]/lib/[x]]
 <+ full-path := <file-exists> $[[<get-project-path>]/src/[x]]
 <+ full-path := <file-exists> $[[<get-project-path>]/syntax/[x]]
 <+ full-path := <file-exists> $[[<get-project-path>]/syn/[x]]
 <+ full-path := <file-exists> $[[<get-project-path>]/src/syntax/[x]]
   		